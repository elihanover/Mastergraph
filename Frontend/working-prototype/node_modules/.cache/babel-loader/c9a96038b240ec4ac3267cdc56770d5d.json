{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the terms of the LICENSE file distributed with this project.\n */\nimport * as tslib_1 from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Keys, Position, removeNonHTMLProps, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { ButtonGroup } from \"../button/buttonGroup\";\nimport { Button } from \"../button/buttons\";\nimport { InputGroup } from \"./inputGroup\";\nvar IncrementDirection;\n\n(function (IncrementDirection) {\n  IncrementDirection[IncrementDirection[\"DOWN\"] = -1] = \"DOWN\";\n  IncrementDirection[IncrementDirection[\"UP\"] = 1] = \"UP\";\n})(IncrementDirection || (IncrementDirection = {}));\n\nvar NumericInput =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(NumericInput, _super);\n\n  function NumericInput(props, context) {\n    var _this = _super.call(this, props, context) || this; // updating these flags need not trigger re-renders, so don't include them in this.state.\n\n\n    _this.didPasteEventJustOccur = false;\n    _this.shouldSelectAfterUpdate = false;\n    _this.delta = 0;\n    _this.intervalId = null;\n\n    _this.inputRef = function (input) {\n      _this.inputElement = input;\n      Utils.safeInvoke(_this.props.inputRef, input);\n    }; // Callbacks - Buttons\n    // ===================\n\n\n    _this.handleDecrementButtonClick = function (e) {\n      _this.handleButtonClick(e, IncrementDirection.DOWN);\n    };\n\n    _this.handleDecrementButtonMouseDown = function (e) {\n      _this.handleButtonClick(e, IncrementDirection.DOWN);\n\n      _this.startContinuousChange();\n    };\n\n    _this.handleDecrementButtonKeyDown = function (e) {\n      _this.updateDelta(IncrementDirection.DOWN, e);\n    };\n\n    _this.handleDecrementButtonKeyUp = function (e) {\n      _this.handleButtonKeyUp(e, IncrementDirection.DOWN, _this.handleDecrementButtonClick);\n    };\n\n    _this.handleIncrementButtonClick = function (e) {\n      _this.handleButtonClick(e, IncrementDirection.UP);\n    };\n\n    _this.handleIncrementButtonMouseDown = function (e) {\n      _this.handleButtonClick(e, IncrementDirection.UP);\n\n      _this.startContinuousChange();\n    };\n\n    _this.handleIncrementButtonKeyDown = function (e) {\n      _this.updateDelta(IncrementDirection.UP, e);\n    };\n\n    _this.handleIncrementButtonKeyUp = function (e) {\n      _this.handleButtonKeyUp(e, IncrementDirection.UP, _this.handleIncrementButtonClick);\n    };\n\n    _this.handleButtonClick = function (e, direction) {\n      var delta = _this.updateDelta(direction, e);\n\n      var nextValue = _this.incrementValue(delta);\n\n      _this.invokeValueCallback(nextValue, _this.props.onButtonClick);\n    };\n\n    _this.handleButtonFocus = function () {\n      _this.setState({\n        isButtonGroupFocused: true\n      });\n    };\n\n    _this.handleButtonBlur = function () {\n      _this.setState({\n        isButtonGroupFocused: false\n      });\n    };\n\n    _this.handleButtonKeyUp = function (e, direction, onClick) {\n      _this.updateDelta(direction, e); // respond explicitly on key *up*, because onKeyDown triggers multiple\n      // times and doesn't always receive modifier-key flags, leading to an\n      // unintuitive/out-of-control incrementing experience.\n\n\n      if (e.keyCode === Keys.SPACE || e.keyCode === Keys.ENTER) {\n        // prevent the page from scrolling (this is the default browser\n        // behavior for shift + space or alt + space).\n        e.preventDefault(); // trigger a click event to update the input value appropriately,\n        // based on the active modifier keys.\n\n        var fakeClickEvent = {\n          altKey: e.altKey,\n          currentTarget: e.currentTarget,\n          shiftKey: e.shiftKey,\n          target: e.target\n        };\n        onClick(fakeClickEvent);\n      }\n    };\n\n    _this.stopContinuousChange = function () {\n      _this.delta = 0;\n\n      _this.clearTimeouts();\n\n      clearInterval(_this.intervalId);\n      document.removeEventListener(\"mouseup\", _this.stopContinuousChange);\n    };\n\n    _this.handleContinuousChange = function () {\n      var nextValue = _this.incrementValue(_this.delta);\n\n      _this.invokeValueCallback(nextValue, _this.props.onButtonClick);\n    }; // Callbacks - Input\n    // =================\n\n\n    _this.handleInputFocus = function (e) {\n      _this.shouldSelectAfterUpdate = _this.props.selectAllOnFocus;\n\n      _this.setState({\n        isInputGroupFocused: true\n      });\n\n      Utils.safeInvoke(_this.props.onFocus, e);\n    };\n\n    _this.handleInputBlur = function (e) {\n      // explicitly set `shouldSelectAfterUpdate` to `false` to prevent focus\n      // hoarding on IE11 (#704)\n      _this.shouldSelectAfterUpdate = false;\n      var baseStateChange = {\n        isInputGroupFocused: false\n      };\n\n      if (_this.props.clampValueOnBlur) {\n        var value = e.target.value;\n\n        var sanitizedValue = _this.getSanitizedValue(value);\n\n        _this.setState(tslib_1.__assign({}, baseStateChange, {\n          value: sanitizedValue\n        }));\n\n        if (value !== sanitizedValue) {\n          _this.invokeValueCallback(sanitizedValue, _this.props.onValueChange);\n        }\n      } else {\n        _this.setState(baseStateChange);\n      }\n\n      Utils.safeInvoke(_this.props.onBlur, e);\n    };\n\n    _this.handleInputKeyDown = function (e) {\n      if (_this.props.disabled || _this.props.readOnly) {\n        return;\n      }\n\n      var keyCode = e.keyCode;\n      var direction;\n\n      if (keyCode === Keys.ARROW_UP) {\n        direction = IncrementDirection.UP;\n      } else if (keyCode === Keys.ARROW_DOWN) {\n        direction = IncrementDirection.DOWN;\n      }\n\n      if (direction != null) {\n        // when the input field has focus, some key combinations will modify\n        // the field's selection range. we'll actually want to select all\n        // text in the field after we modify the value on the following\n        // lines. preventing the default selection behavior lets us do that\n        // without interference.\n        e.preventDefault();\n\n        var delta = _this.updateDelta(direction, e);\n\n        _this.incrementValue(delta);\n      }\n\n      Utils.safeInvoke(_this.props.onKeyDown, e);\n    };\n\n    _this.handleInputKeyPress = function (e) {\n      // we prohibit keystrokes in onKeyPress instead of onKeyDown, because\n      // e.key is not trustworthy in onKeyDown in all browsers.\n      if (_this.props.allowNumericCharactersOnly && _this.isKeyboardEventDisabledForBasicNumericEntry(e)) {\n        e.preventDefault();\n      }\n\n      Utils.safeInvoke(_this.props.onKeyPress, e);\n    };\n\n    _this.handleInputPaste = function (e) {\n      _this.didPasteEventJustOccur = true;\n      Utils.safeInvoke(_this.props.onPaste, e);\n    };\n\n    _this.handleInputChange = function (e) {\n      var value = e.target.value;\n      var nextValue;\n\n      if (_this.props.allowNumericCharactersOnly && _this.didPasteEventJustOccur) {\n        _this.didPasteEventJustOccur = false;\n        var valueChars = value.split(\"\");\n        var sanitizedValueChars = valueChars.filter(_this.isFloatingPointNumericCharacter);\n        var sanitizedValue = sanitizedValueChars.join(\"\");\n        nextValue = sanitizedValue;\n      } else {\n        nextValue = value;\n      }\n\n      _this.shouldSelectAfterUpdate = false;\n\n      _this.setState({\n        value: nextValue\n      });\n\n      _this.invokeValueCallback(nextValue, _this.props.onValueChange);\n    };\n\n    _this.state = {\n      stepMaxPrecision: _this.getStepMaxPrecision(props),\n      value: _this.getValueOrEmptyValue(props.value)\n    };\n    return _this;\n  }\n\n  NumericInput.prototype.componentWillReceiveProps = function (nextProps) {\n    _super.prototype.componentWillReceiveProps.call(this, nextProps);\n\n    var value = this.getValueOrEmptyValue(nextProps.value);\n    var didMinChange = nextProps.min !== this.props.min;\n    var didMaxChange = nextProps.max !== this.props.max;\n    var didBoundsChange = didMinChange || didMaxChange;\n    var sanitizedValue = value !== NumericInput.VALUE_EMPTY ? this.getSanitizedValue(value,\n    /* delta */\n    0, nextProps.min, nextProps.max) : NumericInput.VALUE_EMPTY;\n    var stepMaxPrecision = this.getStepMaxPrecision(nextProps); // if a new min and max were provided that cause the existing value to fall\n    // outside of the new bounds, then clamp the value to the new valid range.\n\n    if (didBoundsChange && sanitizedValue !== this.state.value) {\n      this.setState({\n        stepMaxPrecision: stepMaxPrecision,\n        value: sanitizedValue\n      });\n      this.invokeValueCallback(sanitizedValue, this.props.onValueChange);\n    } else {\n      this.setState({\n        stepMaxPrecision: stepMaxPrecision,\n        value: value\n      });\n    }\n  };\n\n  NumericInput.prototype.render = function () {\n    var _a = this.props,\n        buttonPosition = _a.buttonPosition,\n        className = _a.className,\n        fill = _a.fill,\n        large = _a.large;\n    var inputGroupHtmlProps = removeNonHTMLProps(this.props, [\"allowNumericCharactersOnly\", \"buttonPosition\", \"clampValueOnBlur\", \"className\", \"large\", \"majorStepSize\", \"minorStepSize\", \"onButtonClick\", \"onValueChange\", \"selectAllOnFocus\", \"selectAllOnIncrement\", \"stepSize\"], true);\n    var inputGroup = React.createElement(InputGroup, tslib_1.__assign({\n      autoComplete: \"off\"\n    }, inputGroupHtmlProps, {\n      intent: this.props.intent,\n      inputRef: this.inputRef,\n      key: \"input-group\",\n      large: large,\n      leftIcon: this.props.leftIcon,\n      onFocus: this.handleInputFocus,\n      onBlur: this.handleInputBlur,\n      onChange: this.handleInputChange,\n      onKeyDown: this.handleInputKeyDown,\n      onKeyPress: this.handleInputKeyPress,\n      onPaste: this.handleInputPaste,\n      value: this.state.value\n    })); // the strict null check here is intentional; an undefined value should\n    // fall back to the default button position on the right side.\n\n    if (buttonPosition === \"none\" || buttonPosition === null) {\n      // If there are no buttons, then the control group will render the\n      // text field with squared border-radii on the left side, causing it\n      // to look weird. This problem goes away if we simply don't nest within\n      // a control group.\n      return React.createElement(\"div\", {\n        className: className\n      }, inputGroup);\n    } else {\n      var incrementButton = this.renderButton(NumericInput.INCREMENT_KEY, NumericInput.INCREMENT_ICON_NAME, this.handleIncrementButtonMouseDown, this.handleIncrementButtonKeyDown, this.handleIncrementButtonKeyUp);\n      var decrementButton = this.renderButton(NumericInput.DECREMENT_KEY, NumericInput.DECREMENT_ICON_NAME, this.handleDecrementButtonMouseDown, this.handleDecrementButtonKeyDown, this.handleDecrementButtonKeyUp);\n      var buttonGroup = React.createElement(ButtonGroup, {\n        className: Classes.FIXED,\n        key: \"button-group\",\n        vertical: true\n      }, incrementButton, decrementButton);\n      var inputElems = buttonPosition === Position.LEFT ? [buttonGroup, inputGroup] : [inputGroup, buttonGroup];\n      var classes = classNames(Classes.NUMERIC_INPUT, Classes.CONTROL_GROUP, (_b = {}, _b[Classes.FILL] = fill, _b[Classes.LARGE] = large, _b), className);\n      return React.createElement(\"div\", {\n        className: classes\n      }, inputElems);\n    }\n\n    var _b;\n  };\n\n  NumericInput.prototype.componentDidUpdate = function () {\n    if (this.shouldSelectAfterUpdate) {\n      this.inputElement.setSelectionRange(0, this.state.value.length);\n    }\n  };\n\n  NumericInput.prototype.validateProps = function (nextProps) {\n    var majorStepSize = nextProps.majorStepSize,\n        max = nextProps.max,\n        min = nextProps.min,\n        minorStepSize = nextProps.minorStepSize,\n        stepSize = nextProps.stepSize;\n\n    if (min != null && max != null && min >= max) {\n      throw new Error(Errors.NUMERIC_INPUT_MIN_MAX);\n    }\n\n    if (stepSize == null) {\n      throw new Error(Errors.NUMERIC_INPUT_STEP_SIZE_NULL);\n    }\n\n    if (stepSize <= 0) {\n      throw new Error(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (minorStepSize && minorStepSize <= 0) {\n      throw new Error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (majorStepSize && majorStepSize <= 0) {\n      throw new Error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (minorStepSize && minorStepSize > stepSize) {\n      throw new Error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);\n    }\n\n    if (majorStepSize && majorStepSize < stepSize) {\n      throw new Error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);\n    }\n  }; // Render Helpers\n  // ==============\n\n\n  NumericInput.prototype.renderButton = function (key, iconName, onMouseDown, onKeyDown, onKeyUp) {\n    return React.createElement(Button, {\n      disabled: this.props.disabled || this.props.readOnly,\n      icon: iconName,\n      intent: this.props.intent,\n      key: key,\n      onBlur: this.handleButtonBlur,\n      onMouseDown: onMouseDown,\n      onFocus: this.handleButtonFocus,\n      onKeyDown: onKeyDown,\n      onKeyUp: onKeyUp\n    });\n  };\n\n  NumericInput.prototype.startContinuousChange = function () {\n    var _this = this; // The button's onMouseUp event handler doesn't fire if the user\n    // releases outside of the button, so we need to watch all the way\n    // from the top.\n\n\n    document.addEventListener(\"mouseup\", this.stopContinuousChange); // Initial delay is slightly longer to prevent the user from\n    // accidentally triggering the continuous increment/decrement.\n\n    this.setTimeout(function () {\n      _this.intervalId = window.setInterval(_this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);\n    }, NumericInput.CONTINUOUS_CHANGE_DELAY);\n  };\n\n  NumericInput.prototype.invokeValueCallback = function (value, callback) {\n    Utils.safeInvoke(callback, +value, value);\n  }; // Value Helpers\n  // =============\n\n\n  NumericInput.prototype.incrementValue = function (delta) {\n    // pretend we're incrementing from 0 if currValue is empty\n    var currValue = this.state.value || NumericInput.VALUE_ZERO;\n    var nextValue = this.getSanitizedValue(currValue, delta);\n    this.shouldSelectAfterUpdate = this.props.selectAllOnIncrement;\n    this.setState({\n      value: nextValue\n    });\n    this.invokeValueCallback(nextValue, this.props.onValueChange);\n    return nextValue;\n  };\n\n  NumericInput.prototype.getIncrementDelta = function (direction, isShiftKeyPressed, isAltKeyPressed) {\n    var _a = this.props,\n        majorStepSize = _a.majorStepSize,\n        minorStepSize = _a.minorStepSize,\n        stepSize = _a.stepSize;\n\n    if (isShiftKeyPressed && majorStepSize != null) {\n      return direction * majorStepSize;\n    } else if (isAltKeyPressed && minorStepSize != null) {\n      return direction * minorStepSize;\n    } else {\n      return direction * stepSize;\n    }\n  };\n\n  NumericInput.prototype.getSanitizedValue = function (value, delta, min, max) {\n    if (delta === void 0) {\n      delta = 0;\n    }\n\n    if (min === void 0) {\n      min = this.props.min;\n    }\n\n    if (max === void 0) {\n      max = this.props.max;\n    }\n\n    if (!this.isValueNumeric(value)) {\n      return NumericInput.VALUE_EMPTY;\n    }\n\n    var nextValue = this.toMaxPrecision(parseFloat(value) + delta); // defaultProps won't work if the user passes in null, so just default\n    // to +/- infinity here instead, as a catch-all.\n\n    var adjustedMin = min != null ? min : -Infinity;\n    var adjustedMax = max != null ? max : Infinity;\n    nextValue = Utils.clamp(nextValue, adjustedMin, adjustedMax);\n    return nextValue.toString();\n  };\n\n  NumericInput.prototype.getValueOrEmptyValue = function (value) {\n    return value != null ? value.toString() : NumericInput.VALUE_EMPTY;\n  };\n\n  NumericInput.prototype.isValueNumeric = function (value) {\n    // checking if a string is numeric in Typescript is a big pain, because\n    // we can't simply toss a string parameter to isFinite. below is the\n    // essential approach that jQuery uses, which involves subtracting a\n    // parsed numeric value from the string representation of the value. we\n    // need to cast the value to the `any` type to allow this operation\n    // between dissimilar types.\n    return value != null && value - parseFloat(value) + 1 >= 0;\n  };\n\n  NumericInput.prototype.isKeyboardEventDisabledForBasicNumericEntry = function (e) {\n    // unit tests may not include e.key. don't bother disabling those events.\n    if (e.key == null) {\n      return false;\n    } // allow modified key strokes that may involve letters and other\n    // non-numeric/invalid characters (Cmd + A, Cmd + C, Cmd + V, Cmd + X).\n\n\n    if (e.ctrlKey || e.altKey || e.metaKey) {\n      return false;\n    } // keys that print a single character when pressed have a `key` name of\n    // length 1. every other key has a longer `key` name (e.g. \"Backspace\",\n    // \"ArrowUp\", \"Shift\"). since none of those keys can print a character\n    // to the field--and since they may have important native behaviors\n    // beyond printing a character--we don't want to disable their effects.\n\n\n    var isSingleCharKey = e.key.length === 1;\n\n    if (!isSingleCharKey) {\n      return false;\n    } // now we can simply check that the single character that wants to be printed\n    // is a floating-point number character that we're allowed to print.\n\n\n    return !this.isFloatingPointNumericCharacter(e.key);\n  };\n\n  NumericInput.prototype.isFloatingPointNumericCharacter = function (character) {\n    return NumericInput.FLOATING_POINT_NUMBER_CHARACTER_REGEX.test(character);\n  };\n\n  NumericInput.prototype.getStepMaxPrecision = function (props) {\n    if (props.minorStepSize != null) {\n      return Utils.countDecimalPlaces(props.minorStepSize);\n    } else {\n      return Utils.countDecimalPlaces(props.stepSize);\n    }\n  };\n\n  NumericInput.prototype.toMaxPrecision = function (value) {\n    // round the value to have the specified maximum precision (toFixed is the wrong choice,\n    // because it would show trailing zeros in the decimal part out to the specified precision)\n    // source: http://stackoverflow.com/a/18358056/5199574\n    var scaleFactor = Math.pow(10, this.state.stepMaxPrecision);\n    return Math.round(value * scaleFactor) / scaleFactor;\n  };\n\n  NumericInput.prototype.updateDelta = function (direction, e) {\n    this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);\n    return this.delta;\n  };\n\n  NumericInput.displayName = DISPLAYNAME_PREFIX + \".NumericInput\";\n  NumericInput.VALUE_EMPTY = \"\";\n  NumericInput.VALUE_ZERO = \"0\";\n  NumericInput.defaultProps = {\n    allowNumericCharactersOnly: true,\n    buttonPosition: Position.RIGHT,\n    clampValueOnBlur: false,\n    large: false,\n    majorStepSize: 10,\n    minorStepSize: 0.1,\n    selectAllOnFocus: false,\n    selectAllOnIncrement: false,\n    stepSize: 1,\n    value: NumericInput.VALUE_EMPTY\n  };\n  NumericInput.DECREMENT_KEY = \"decrement\";\n  NumericInput.INCREMENT_KEY = \"increment\";\n  NumericInput.DECREMENT_ICON_NAME = \"chevron-down\";\n  NumericInput.INCREMENT_ICON_NAME = \"chevron-up\";\n  /**\n   * A regex that matches a string of length 1 (i.e. a standalone character)\n   * if and only if it is a floating-point number character as defined by W3C:\n   * https://www.w3.org/TR/2012/WD-html-markup-20120329/datatypes.html#common.data.float\n   *\n   * Floating-point number characters are the only characters that can be\n   * printed within a default input[type=\"number\"]. This component should\n   * behave the same way when this.props.allowNumericCharactersOnly = true.\n   * See here for the input[type=\"number\"].value spec:\n   * https://www.w3.org/TR/2012/WD-html-markup-20120329/input.number.html#input.number.attrs.value\n   */\n\n  NumericInput.FLOATING_POINT_NUMBER_CHARACTER_REGEX = /^[Ee0-9\\+\\-\\.]$/;\n  NumericInput.CONTINUOUS_CHANGE_DELAY = 300;\n  NumericInput.CONTINUOUS_CHANGE_INTERVAL = 100;\n  return NumericInput;\n}(AbstractPureComponent);\n\nexport { NumericInput };","map":null,"metadata":{},"sourceType":"module"}